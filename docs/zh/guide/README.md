# 介绍

`Gozz` 由两部分组成：

- [gozz-core](https://github.com/go-zing/gozz-core) 是核心依赖库，包含了代码文件解析，注解解析，结构化注解对象，
  运行时对象索引，缓存等核心功能依赖。同时为各个插件提供包含模版、生成、编辑、追加文件相关的工具依赖。

- [gozz](https://github.com/go-zing/gozz) 是用户使用该项目的 cli 工具运行入口，
  包含了对用户命令的解析，插件的加载和实例化，以及对外部扩展的加载。

笔者还提供了一系列强大的内置插件，囊括了在以往工作中开发这些插件雏形时，
希望能够规范化解决，以及将这些优秀设计实践在团队快速落地的一些技术性需求，包括：

- 优化系统依赖架构设计提升项目质量和可维护性，提升多人大型项目人效协作效率
- 快速构建API和输出API文档、业务领域文档，降低API及文档持续迭代和多分发的成本
- 通过灵活切面化注入设计提升可观测性和降低变更复杂度，降低开发者工作量及扰动感知

## 理念

编程 就是将 **重复、繁琐的事情** ，将成熟的方案 通过程序化实现高效、低成本、规范化地解决。

而我们的设计和开发过程中本身有很多工作，本身也是 **重复、繁琐的事情**。

在我们一遍又一遍地去浪费时间做这些 低效开发时 本身就违背了编程的初衷和思想。

因此 `Gozz` 希望 将成熟的技术方法论 和 优秀的系统架构方案 高效、低成本、规范化地传播和落地。

并希望大家由此能：

> Less, But Better

而 `Gozz` 实现这点的理念就是：

> 最好的代码，是不需要每个人都写的代码

通过代码生成和编辑，提供最佳实践，或提供最佳实践的模板化入口。

### 交互设计理念

`Gozz` 遵循 [约定优于配置](https://zh.wikipedia.org/wiki/%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE)

会尽可能使用 **简洁** 和 **符合人类直觉** 的 命令 / 注解 / 参数

## 适用场景

### 个人

`Gozz` 不会在 Feature 中强调对初阶 Gopher 的友好性，因为 **`注释注解`是非官方的特性** ，我们不希望引入额外认知成本 从而影响
Gopher 对 Golang 本身的学习曲线。

一方面 `Gozz` 部分插件的生成结果的使用 需要开发者对 Golang 类型和 `interface` 系统 甚至 `reflect` 有一定深入认知。

另一方面 对于 `Gozz 解决的到底是什么问题` 也需要对 `团队协作 / 系统架构 / 设计模式` 有一定的前置认知。

如果你有使用 `JAVA Spring` 的经验，那么恭喜，你可以有一定的认知优势。

`Gozz` 解决需求的思路学习了 `JAVA Spring` 一些重要设计思想，**但绝不是拙劣地模仿**。

### 团队

`人月神话` 中有 `保有概念整体性` 的说法 这个系统设计理念也是笔者比较认同 即：

**系统的核心架构设计 需要由少数人专制控制**

因此，使用 `Gozz` 的时候，团队需要由一个核心的资深角色给出适合团队的 `Gozz` 配置 以及 维护生成模板和适配层。

在团队内，即使是不同的业务项目，在 `Gozz` 的使用都不应该产生过多分歧。

而其他成员只需要遵循团队的规范，将运行 `Gozz` 的指令写到 项目 `Makefile` 或构建工具，在 代码变更 及 提交之前 去执行。

---

在确保企业生产稳定性后，`Gozz` 鼓励所有团队角色去主动探索和学习，如何去优化业务和项目的架构设，用更低的成本办更多更好的事。

`Gozz` 也将会在项目示例中提供一些最佳实践供开发者们参考。

### 微服务 or 单体

`Gozz` 的应用并不局限于微服务场景，相反，越大型的项目和协作团队，相信会越容易从 `Gozz` 中受益更多。

[前世今生](../past-and-present) 中有提到：一些内置插件的前身，就是为了优化数十万行级系统代码重构需求而生。

微服务，只代表个别服务在业务依赖领域设计中的 `Micro / Pluggable / Extensible` ，但从不意味着该项目代码架构层级和设计简单，
或该服务维系人员较少。

如果你希望团队的微服务项目代码质量和协作效率能够得到一定的提升，也欢迎使用 `Gozz` 和我们提供的各个内置插件功能。
