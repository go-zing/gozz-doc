# Introduction

`Gozz` was made from two partsï¼š

- [gozz](https://github.com/go-zing/gozz) is CLI for the project.
  It manages the runtime of process,
  parses commands and invokes plugins or extension plugins.
- [gozz-core](https://github.com/go-zing/gozz-core) provides core library,
  contains code and annotations parsing, object types,
  caches and so one core functional dependencies.
  It also provides tools on handing codes and files for plugins.

`Gozz` provides a series of [built-in plugins](plugins),
dedicated to providing tool-based solutions for some of the technical needs,
that have been summarized and accumulated in the past.

[gozz-doc-examples](https://github.com/go-zing/gozz-doc-examples) contains examples for all builtin plugins,
[Plugins](plugins) would provide comparative reading.

Also, you can explore more external plugins in [gozz-plugins](https://github.com/go-zing/gozz-plugins).
These externals were based on [Golang .so plugin](https://pkg.go.dev/plugin),
and we provide command tool to [install plugin](getting-started.md#gozz-install) automatically.
So developers could do expand development easily.

:::tip Style
`Gozz` emphasizes progressive idempotent equation generation,
and provide stable automated code iteration integration through consistent commands and configurations to fulfill
requirements continuous changing.
:::

## Vision

Programming is to take **repetitive and tedious things** and program mature solutions to achieve efficient, low-cost,
and standardized solutions.

There is a lot of work in our design and development process, which is also **repetitive and tedious**.

When we waste time doing these inefficient development over and over again, it itself goes against the original
intention and idea of programming.

Through tooling, `Gozz` hopes to help spread and implement **mature technology methodologies** and **excellent practice
plans**:

Provide best practices through code generation and editing, or provide access to templated best practices.

> The best code is code that nobody repeat

And hope that we can:

> Less, But Better

## Design Concept

`Gozz` follows [Convention Over Configuration](https://en.wikipedia.org/wiki/Convention_over_configuration)

And prefer commands/annotations/parameters that are **concise** and
**in line with human intuition** as much as possible

## Applicable scene

### personal

First of all, before using `Gozz`, I hope you can clearly understand: **Annotations are not an official Golang feature**

For developers who don't know this, I would recommend learning Golang through other tutorials first.

<br>

Then, using `Gozz` well requires a certain amount of pre-knowledge:

- To understand the use of the code generated by the `Gozz` plugins, you need to have a certain understanding of Golang
  `type / interface / reflect`.
- Understanding `what problem Gozz solves` requires a certain understanding
  of `team collaboration / system architecture / design patterns`.

<br>


::: tip
If you have experience using `JAVA Spring`, you can have certain cognitive advantages.

`Gozz` learned some important design ideas of `JAVA Spring`, but **it is by no means a poor imitation.**
:::

### Team

There is a point in [The mythical man-month](https://en.wikipedia.org/wiki/The_Mythical_Man-Month)
about `conceptual integrity`.
This system design concept is also one that the author agrees with:

**The core architecture design of the system needs to be autocratically controlled by a few people.**

Therefore, the team needs a core senior role to provide the `Gozz` configuration suitable for the team,
and maintain the generated templates and adaptation layers.

Within the team, how to configure `Gozz` and its templates should not cause too much disagreement.

Other members should follow the team's specifications to run `Gozz` within `Makefile` or DevOps pipeline,
and execute them before commit or build.

<br>

Ensuring production stability,
`Gozz` still encourages every team roles to actively explore and learn how to optimize the
architectural design of business and projects, and do more and better things at lower costs.

We would also provide some best practices in project examples for developers to refer to.

### Micro or Monolith

`Gozz` is never limited to micro. On the contrary, the larger the projects and collaborative teams,
the better it will be to benefit more from `Gozz`.

[Story Parts](../story.md) would introduce:
The predecessors of some built-in plugins were created to optimize the
reconstruction needs of some code system projects with lines and lines of codes.

Microservices only represent the `Micro / Pluggable / Extensible`
of individual services in the design of business dependency areas,
but it never means that the project code architecture and design may be simple.
Or the service has fewer maintenance staff.

If you want to improve the code quality and collaboration efficiency of your team's projects,
you are also welcome to try `Gozz` and the awesome built-in plugins it provides.
